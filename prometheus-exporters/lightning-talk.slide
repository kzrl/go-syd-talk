# How to Monitor your House with a Prometheus Exporter in Go

21 Aug 2025


Karl Cordes
karl@cordes.com.au

-----

## What is Prometheus?

**Pull-based monitoring system:**
- Prometheus server scrapes targets at a specified interval
- Targets expose metrics on `/metrics` endpoint
- Simple text format


## /metrics

.code metrics.txt


## The Problem 

I want to monitor:
- Air quality sensors (Awair)
- Air conditioner (Daikin)  
- Solar panels (Fronius)
- Weather station (Ecowitt)

They all have their own mobile apps and hosted services.


Something running locally is better and faster.

**Solution**: Write a custom Prometheus exporter!

-----

## What's a Prometheus Exporter?

A program that:
- Collects metrics from a source
- Translates to Prometheus format
- Serves them on `/metrics` endpoint

-----

## House Monitoring Architecture

.image house-monitoring.png _ 1000

One Go binary polling all devices and exporting metrics on /metrics

-----

## Why Go? üöÄ

Easy to deploy and run on anything I want to use as a server.

```bash
 GOOS=linux GOARCH=amd64 go build -o house cmd/main.go
 rsync -avz house k@server:~/bin/
 ssh k@server -t 'sudo systemctl restart house.service'
```

Single binary - no runtime dependencies ‚ù§Ô∏è


-----

## Prometheus Metric Types üìä

**Counter** - Only goes up (resets on restart)
```go
http_requests_total
errors_total
```

**Gauge** - Goes up and down
```go
temperature_celsius
memory_usage_bytes
concurrent_connections
```

**Histogram** - Buckets of observations
```go
http_request_duration_seconds
```


-----

## Labels

**DO:**
Bounded cardinality
```go

http_requests{method="GET", status="200"}
temperature{location="bedroom", sensor="awair"}
```

**DON'T:**
```go
// Bad - unbounded cardinality!
http_requests{user_id="12345"}  // Millions of users
api_calls{session_id="abc123"}  // Unique per session
```

**Rule**: Labels should have <100 unique values per label

-----

## The Collector Interface üéØ

```go
// Prometheus defines this interface
type Collector interface {
    // Describe sends metric descriptions
    Describe(chan<- *prometheus.Desc)
    
    // Collect sends actual metric values
    Collect(chan<- prometheus.Metric)
}
```

**Key insight**: Implement these 2 methods = instant exporter!

-----

## Real Implementation: Awair

```go
// house/awair/collector.go
type AwairCollector struct {
    devices    map[string]string  // IP -> location
    tempDesc   *prometheus.Desc
    co2Desc    *prometheus.Desc
    pm25Desc   *prometheus.Desc
}

func (c *AwairCollector) Describe(ch chan<- *prometheus.Desc) {
    ch <- c.tempDesc
    ch <- c.co2Desc
    ch <- c.pm25Desc
}

func (c *AwairCollector) Collect(ch chan<- prometheus.Metric) {
    for ip, location := range c.devices {
        data, _ := c.fetchLiveData(ip)
        ch <- prometheus.MustNewConstMetric(
            c.tempDesc, prometheus.GaugeValue, 
            data.Temp, location)
    }
}

-----

## Fetching from Devices

```go
// house/awair/awair.go - Real device API call
func GetLiveData(hostname string) (LiveData, error) {
    endpoint := fmt.Sprintf("http://%s/air-data/latest", hostname)
    
    resp, err := http.Get(endpoint)
    if err != nil {
        return LiveData{}, err
    }
    defer resp.Body.Close()
    
    var ld LiveData
    json.NewDecoder(resp.Body).Decode(&ld)
    return ld, nil
}
```

-----

## Update Metrics with Labels

```go
// house/awair/awair.go
units := map[string]string{
    "192.168.1.12": "bedroom",
    "192.168.1.11": "office",
}

for ip, room := range units {
    data, _ := GetLiveData(ip)
    
    m.Temp.With(prometheus.Labels{
        "location": room
    }).Set(data.Temp)
    
    m.CO2.With(prometheus.Labels{
        "location": room
    }).Set(float64(data.CO2))
}

-----

## Wire It All Together! üîå

```go
// house/cmd/main.go - Using the Collector pattern!
func main() {
    // Create non-global registry
    reg := prometheus.NewRegistry()
    
    // Register collectors - they handle their own goroutines
    reg.MustRegister(ecowitt.NewEcowittCollector())
    reg.MustRegister(awair.NewAwairCollector())
    reg.MustRegister(daikin.NewDaikinCollector())
    
    // That's it! Prometheus calls Collect() on each scrape
    http.Handle("/metrics", 
        promhttp.HandlerFor(reg, promhttp.HandlerOpts{}))
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

-----

## See Real Metrics! üéØ

```bash
$ curl localhost:8080/metrics | grep awair
awair_temperature_celcius{location="bedroom"} 22.3
awair_temperature_celcius{location="office"} 24.1
awair_CO2{location="bedroom"} 412
awair_CO2{location="office"} 523
awair_PM25{location="bedroom"} 3
awair_humidity{location="bedroom"} 65.2

daikin_indoor_temp 23.5
daikin_power 1  # AC is on!
fronius_power_pv_watts 3420  # Solar generating!
```

-----

## Collector Pattern Benefits ‚ú®

```go
// Old way: Polling in goroutines
go awair.GetMetrics(*awair)  // Polls every minute
go daikin.GetMetrics(*daikin)  // More goroutines...

// New way: Collector interface
reg.MustRegister(awair.NewAwairCollector())
// Prometheus calls Collect() when it scrapes
```

**Benefits:**
- No polling loops or goroutines needed
- Metrics always fresh when Prometheus scrapes
- Built-in error handling with `up` metric
- Follows Prometheus best practices

-----

## Weather Station polling

```go
// house/ecowitt/ecowitt.go - Weather station with many sensors
func GetMetrics(m Metrics) {
    for {
        data, _ := GetLiveData()  // JSON from weather station
        
        // Indoor sensor
        for _, unit := range data.WH25 {
            temp, _ := strconv.ParseFloat(unit.Temp, 64)
            m.Temp.With(prometheus.Labels{"location": "office"}).Set(temp)
        }
        
        // Multiple outdoor sensors with names!
        for _, ch := range data.ChAisle {
            temp, _ := TempToFloat64(ch.Temp)
            humidity, _ := HumidityToFloat64(ch.Humidity)
            
            m.Temp.With(prometheus.Labels{"location": ch.Name}).Set(temp)
            m.Humidity.With(prometheus.Labels{"location": ch.Name}).Set(humidity)
            
            // Calculate dew point from temp & humidity
            dewpoint, _ := DewPoint(temp, humidity)
            m.DewPoint.With(prometheus.Labels{"location": ch.Name}).Set(dewpoint)
        }
        
        time.Sleep(1 * time.Minute)
    }
}
```

-----

## Polling vs Collector Pattern üîÑ

**Polling Method (Old Way):**
```go
// Goroutines continuously poll devices
go func() {
    for {
        data := fetchFromDevice()
        metric.Set(data.Value)
        time.Sleep(1 * time.Minute)  // Fixed interval
    }
}()
```
Problems: Resource waste, stale metrics, timing mismatches

**Collector Pattern (Better):**
```go
func (c *MyCollector) Collect(ch chan<- prometheus.Metric) {
    data := fetchFromDevice()  // Only when Prometheus scrapes
    ch <- prometheus.MustNewConstMetric(desc, GaugeValue, data.Value)
}
```
Benefits: On-demand, fresh data, resource efficient

-----

## A single pane of glass for the gadgets

- Air quality
- Solar panel production
- Air conditioner status
- Weather station data

**One Go binary exports all the metrics for Prometheus**


-----

## Resources üìö

.link https://prometheus.io/docs/instrumenting/writing_exporters/ Writing Exporters

.link https://github.com/prometheus/client_golang Go client library

## Questions? ü§î

